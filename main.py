import json # Json file generated by ChatGPT
import pygame

# Open pieces.json with pieces informations
with open("pieces.json") as f:
    pieces = json.load(f)

# Initialize Pygame
pygame.init()

# Layout settings
screen_width = 1000
square_size = screen_width // 8
primary_square_color = "#d5c9bb"
secondary_square_color = "#b2a696"

#¼
screen = pygame.display.set_mode((screen_width, screen_width))
 
current_player = "White" # white start
running = True
dragging_piece = None  # Currently dragged piece

# Dictionaries for images and starting positions
pieces_images =  {} 
pieces_positions = {}
pieces_color = {}


for piece in pieces["pieces"]:
        piece_id = piece["id"] # un ID différent pour chaque pièce pour eviter de reécrire par dessus
        pieces_color[piece_id] = piece["color"]
        image = pygame.image.load(piece["image"]) # prend l'image de chaque pièce
        pieces_images[piece_id] = pygame.transform.scale(image, (square_size, square_size)) # redimensionne l'image
        pieces_positions[piece_id] = piece["position"] # prend la position de chaque pièce

# Draw a chess grid by coloring every other square. 
def draw_chessboard():
    for row in range(8):
        for col in range(8):
            # Determines the color of the square
            color = pygame.Color(primary_square_color) if (row + col) % 2 == 0 else pygame.Color(secondary_square_color)
            # Draw the square
            pygame.draw.rect(screen, color, (col * square_size, row * square_size, square_size, square_size))

# Draw a piece by taking the piece image and initial cordonates
def draw_piece(piece_name, x, y):
    image = pieces_images[piece_name]
    pos_x = (x * square_size) + (square_size - image.get_width()) // 2
    pos_y = (y * square_size) + (square_size - image.get_height()) // 2
    rect = pygame.Rect(pos_x, pos_y, image.get_width(), image.get_height())
    screen.blit(image, (pos_x, pos_y))
    return rect

def move_piece(piece_id, new_position): # déplace une pièce et capture une autre si necessaire
    global pieces_positions #Accède à la variable globale pieces_positions qui contient les positions actuelles de toutes les pièces
    
    for target_id, target_pos in pieces_positions.items(): # parcourt toutes les pièces du jeu
        current_color = next(piece["color"] for piece in pieces["pieces"] if piece["id"] == dragging_piece)
        target_color = next(piece["color"] for piece in pieces["pieces"] if piece["id"] == target_id)
    
        if target_pos == new_position and target_id != piece_id and current_color != target_color: #si la position de la cible est la même que la nouvelle position de la pièce jouée et qu'elles ne sont pas les mêmes  
            del pieces_positions[target_id] # capture
            break # arrête la bouvle dès qu'une pièce est mangée

    pieces_positions[piece_id] = new_position # met à jour la position
                 

def handle_drag_and_drop():
    global dragging_piece, piece_id, pieces_color, current_player
    # Prevents from crashing
    move_made = False
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            return False

        # Detect mouse button down to start dragging
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:  # Check if left button is pressed
            mouse_x, mouse_y = pygame.mouse.get_pos() # Get x, y cordonates of the mouse
            for piece_id, (piece_x, piece_y) in pieces_positions.items(): # Get x, y cordonates and id of the pieces
                piece_rect = draw_piece(piece_id, piece_x, piece_y) # Draw the piece 

                if piece_rect.collidepoint(mouse_x, mouse_y): # Verify if the piece collide with the mouse 
                    dragging_piece = piece_id # Set the piece as beeing dragged
                    break

        # Detect mouse button up to drop the piece
        if event.type == pygame.MOUSEBUTTONUP and event.button == 1: # Check if left butter has been unpressed
            if dragging_piece: # Check if a piece if beeing dragged
                mouse_x, mouse_y = pygame.mouse.get_pos() # Get x, y cordonates of the mouse 
                new_x, new_y = mouse_x // square_size, mouse_y // square_size  # Snap the piece to the nearest square
                if 0 <= new_x < 8 and 0 <= new_y < 8: # Chessboard limit
                    
                    actual_position = pieces_positions[dragging_piece]

                    piece_settings = next(piece for piece in pieces["pieces"] if piece["id"] == dragging_piece)
                    piece_owner = next(piece["color"] for piece in pieces["pieces"] if piece["id"] == dragging_piece)
                    
                    piece_type = piece_settings["type"]
                    initial_position = piece_settings["position"]

                    is_allowed = False
                            
                    if piece_type == "Black_Pawn":
                        allowed_x_moves = [0]
                        if actual_position == initial_position:
                            allowed_y_moves = [1, 2]
                        else:
                            allowed_y_moves = [1]

                        if (actual_position[0] - new_x in allowed_x_moves) and (actual_position[1] - new_y in allowed_y_moves):
                            is_allowed = True

                    if piece_type == "White_Pawn":
                        allowed_x_moves = [0]
                        if actual_position == initial_position:
                            allowed_y_moves = [-1, -2]
                        else:
                            allowed_y_moves = [-1]

                        if (actual_position[0] - new_x in allowed_x_moves) and (actual_position[1] - new_y in allowed_y_moves):
                            is_allowed = True
                    
                    elif piece_type == "Knight":
                        if (abs(actual_position[0] - new_x) == 2 and abs(actual_position[1] - new_y) == 1) or (abs(actual_position[0] - new_x) == 1 and abs(actual_position[1] - new_y) == 2):
                            is_allowed = True

                    elif piece_type == "Bishop": 
                        if abs(actual_position[0] - new_x) == abs(actual_position[1] - new_y):
                            is_allowed = True    

                    elif piece_type == "Rook":
                        allowed_y_moves = [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7,]
                        allowed_x_moves = [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7,]

                        if ((actual_position[0] - new_x in allowed_x_moves) and (actual_position[1] - new_y == 0)) or ((actual_position[0] - new_x == 0) and (actual_position[1] - new_y in allowed_y_moves)):
                            is_allowed = True

                    
                    elif piece_type == "Queen":
                        allowed_y_moves = [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7,]
                        allowed_x_moves = [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7,]

                        if (((actual_position[0] - new_x in allowed_x_moves) and (actual_position[1] - new_y == 0)) or ((actual_position[0] - new_x == 0) and (actual_position[1] - new_y in allowed_y_moves))) or abs(actual_position[0] - new_x) == abs(actual_position[1] - new_y):
                            is_allowed = True

                    elif piece_type == "King":
                        allowed_x_moves = [-1, 0, 1]
                        allowed_y_moves = [-1, 0, 1]
                        
                        if (actual_position[0] - new_x in allowed_x_moves) and (actual_position[1] - new_y in allowed_y_moves):
                            is_allowed = True

                    if piece_owner != current_player:
                        is_allowed = False 
                    
                    print(piece_owner)

                    for position in pieces_positions:
                        if [new_x, new_y] == pieces_positions[position] and piece_owner == pieces_color[position]:
                            is_allowed = False
                        
                    if is_allowed:
                        pieces_positions[dragging_piece] = [new_x, new_y]
                        move_piece(dragging_piece, [new_x, new_y])
                        dragging_piece = None
                        move_made = True

                    else:
                        dragging_piece = None 
                        print("Movement in not allowed")

                    if move_made:
                        current_player = "Black" if current_player == "White" else "White"   
                else:
                    print("Invalid movement") 

    return True

# Main loop
while running:
    running = handle_drag_and_drop()

    # Draw chessboard
    draw_chessboard()

    # Draw all pieces
    for piece_name, (piece_x, piece_y) in pieces_positions.items():
        if piece_name == dragging_piece:
            # If dragging, move the piece with the mouse
            mouse_x, mouse_y = pygame.mouse.get_pos()
            pos_x = mouse_x - (square_size // 2)
            pos_y = mouse_y - (square_size // 2)
            screen.blit(pieces_images[piece_name], (pos_x, pos_y))
        else:
            draw_piece(piece_name, piece_x, piece_y)

    pygame.display.flip()

# Quit Pygame
pygame.quit()


