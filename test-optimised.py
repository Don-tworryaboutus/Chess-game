import json # Json file generated by ChatGPT
import pygame # Import pygame to create a GUI

with open("pieces.json") as f:
    pieces = json.load(f) # Set pieces settings

screen_width = 1000 # Set the width (and the height) of the window
square_size = screen_width // 8 # Set the width and the height of the squares
light_square_color = "#d5c9bb" # Light Squares color
dark_square_color = "#b2a696" # Dark Squares color

screen = pygame.display.set_mode((screen_width, screen_width)) # Apply the height to the window

current_player = "White" # The whites start
running = True # Main loop variable
dragging_piece = None

# These are empty dictionaries that will be filled later in the code
pieces_colors = {} # Create a dictionary with every piece color
pieces_positions = {} # Create a dictionary with every piece position
pieces_images = {} # Create a dictionary with every piece image

# Get precises pieces settings
for piece in pieces["pieces"]:
    piece_id = piece["id"] # Get piece id 
    pieces_colors[piece_id] = piece["color"] # Get piece color ans add it into the pieces_colors dictionary
    pieces_positions[piece_id] = piece["position"] # Get piece position ans add it into the pieces_position dictionary
    piece_image = pygame.image.load(piece["image"]) # Get the image path
    pieces_images[piece_id] = pygame.transform.scale(piece_image, (square_size, square_size)) # Transform image to the right size and add it into pieces_image dictionary

# Draws a chess grid by coloring every other square. 
def draw_chessboard():
    for row in range(8):
        for col in range(8):
            color = pygame.Color(light_square_color) if (row + col) % 2 == 0 else pygame.Color(dark_square_color) # Determines the color of the square if the square "coordinate" is odd or even
            pygame.draw.rect(screen, color, (col * square_size, row * square_size, square_size, square_size)) # Draws the square 

def draw_piece(piece_id, piece_x_position, piece_y_position):
    piece_image = pieces_images[piece_id] # Get precise image path
    grid_x_position = (piece_x_position * square_size) + (square_size - piece_image.get_width()) // 2 # Get the correct column
    grid_y_position = (piece_y_position * square_size) + (square_size - piece_image.get_width()) // 2 # Get tje correct row
    screen.blit(piece_image, (grid_x_position, grid_y_position)) # Display the piece on the screen

def can_move(piece_id):
    piece_color = pieces_colors[piece_id] # Check if current player is playing
    return piece_color == current_player

def move_piece(piece_id, new_piece_x_position, new_piece_y_position):
    if can_move(piece_id) and catch_piece(piece_id, new_piece_x_position, new_piece_y_position):
        pieces_positions[piece_id] = [new_piece_x_position, new_piece_y_position] # move the piece 
        global current_player
        current_player = "Black" if current_player == "White" else "White" # Change player when played
    else:
        print("Movement is not allowed")

def catch_piece(piece_id, new_piece_x_position, new_piece_y_position):
    new_piece_position = [new_piece_x_position, new_piece_y_position]
    piece_color = pieces_colors[piece_id]

    for target_id, target_position in list(pieces_positions.items()):
        if target_position == new_piece_position and target_id != piece_id:
            if piece_color != pieces_colors[target_id]:
                del pieces_positions[target_id]
            else:
                return False
    return True

def handle_drag_and_drop():
    global dragging_piece
    
    mouse_x_coordinate, mouse_y_coordinate = pygame.mouse.get_pos()  # Get x, y coordinates of the mouse

    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:  # Detect if left mouse button is pressed
        for piece_id, (piece_x_position, piece_y_position) in pieces_positions.items(): # Get every pieces x, y position on pieces_positions

            piece_image = pieces_images[piece_id]
            grid_x_position = (piece_x_position * square_size) + (square_size - piece_image.get_width()) // 2 # Get the correct column
            grid_y_position = (piece_y_position * square_size) + (square_size - piece_image.get_height()) // 2 # Get the correct row
            piece_rect = pygame.Rect(grid_x_position, grid_y_position, piece_image.get_width(), piece_image.get_height()) # Get the rectangle of the piece
            
            if piece_rect.collidepoint(mouse_x_coordinate, mouse_y_coordinate): # Verify if the piece collide with the mouse
                dragging_piece = piece_id # Set the piece as beeing dragged

    if event.type == pygame.MOUSEBUTTONUP and event.button == 1:
        if dragging_piece: # Check if a piece is beeing dragged
            new_piece_x_position, new_piece_y_position = mouse_x_coordinate // square_size, mouse_y_coordinate // square_size # Set the new coordinates into a square
            move_piece(dragging_piece, new_piece_x_position, new_piece_y_position) # Move the piece
            dragging_piece = False

while running:
    # Prevents from crashing
    for event in pygame.event.get(): 
        if event.type == pygame.QUIT:
            running = False

    # Draws the chessboard
    draw_chessboard()

    # Handle drag and drop
    handle_drag_and_drop()

    # Draws the pieces 
    for piece_id, (piece_x_position, piece_y_position) in pieces_positions.items(): 
        if piece_id == dragging_piece:
            mouse_x_coordinate, mouse_y_coordinate = pygame.mouse.get_pos() # Get x, y coordinates of the mouse
            piece_x_position = mouse_x_coordinate - (square_size // 2)
            piece_y_position = mouse_y_coordinate - (square_size // 2)
            screen.blit(pieces_images[piece_id], (piece_x_position, piece_y_position)) # Draws the piece at the new place, we can't use the draw_piece function because that will make disapear the piece while dragged.
        else :
            draw_piece(piece_id, piece_x_position, piece_y_position) # Draws the piece

    # Display the window 
    pygame.display.flip()

# Quit Pygame
pygame.quit()